/* 
 * DEVS-TOSSIM - a DEVS framework for simulation of TinyOS wireless sensor networks
 * Copyright (c) 2013 Ricardo Guido Marelli
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * ---
 * The TinyOSProcessor class
 */

#ifndef __DEVS_MOTE_PROCESSOR__
#define __DEVS_MOTE_PROCESSOR__

#include "Interface.h"
#include <model/AbstractProcessor.h>
#include <map>
#include <string>

#include <Logger.h>

const std::string PROCESSOR_SLEEPING 		  = "sleeping";
const std::string PROCESSOR_EXECUTING_EVENT   = "executing_event";
const std::string PROCESSOR_WORKING 		  = "working";
const std::string PROCESSOR_POST_WORK 		  = "post_work";

extern "C" {
    int sim_main_start_mote(); 
}

class TinyOSProcessor : public AbstractProcessor
{
public:
    TinyOSProcessor(const std::string &name, unsigned long mote_id) : AbstractProcessor(name), mote_id_(mote_id), 
                                                                      runTaskFunction_(NULL),
                                                                      started_(false)
    {

        registerPhase(PROCESSOR_SLEEPING);
        registerPhase(PROCESSOR_EXECUTING_EVENT);
        registerPhase(PROCESSOR_WORKING);
        registerPhase(PROCESSOR_POST_WORK);

        setPhase(PROCESSOR_WORKING);
        setSigma(0);

        // Sleep is generated by TinyOS MCUSleep.
        // We can't make a phase change when generating output, so we need an additional port 
        // in order to produce an external transition.
        // The alternative was to use runTaskFunction() output value but it add's an odd dependency.
        outputPorts().add(DEVS::Port(name,"Sleep",1));
        inputPorts().add(DEVS::Port(name,"SleepIn",1));
    }

    void internalTransition() {
        set_sim_node(mote_id(),this->timer_tn());

        if(!started_) {
            sim_main_start_mote(); 
            started_=true;
            return;
        }

        doInternalTransition();
    }

    void externalTransition(DEVS::ExternalMessage* message) {
        set_sim_node(mote_id(),this->timer_tn());
        doExternalTransition(message);
    }

    virtual DEVS::OutputMessage* outputFunction();

    unsigned long mote_id() { return mote_id_; }

    /* Functions called from TinyOS */
    void registerRunTaskFunction(RunTaskFunctionHandle runTaskFunction);
    void registerExternalEvent(const char* portname,ExternalMessageHandler handle);
    void putOutputMessage(const char* state_name, const char* port_name, 
                          const void* content, unsigned int content_size);

protected:
    
    uint32_t timer_tn() {
        uint32_t t = this->tn().sec()*1000;
        return t + this->tn().msec();
    }

    ExternalMessageHandler getExternalMessageHandler(std::string port_name) {
        ExternalMensageHandlerMap::iterator it = externalMessageHandlers_.find(port_name);
        if(it == externalMessageHandlers_.end()) return NULL;
        return it->second;
    }


    virtual void doExternalTransition(DEVS::ExternalMessage* message);
    virtual void doInternalTransition();

    int runTaskFunction() {
        if(runTaskFunction_ != NULL) {
            return runTaskFunction_();
        }
        // No task function defined. Usually this means a wrong state.
        return -1;
    }


protected:
    typedef std::map<std::string, ExternalMessageHandler> ExternalMensageHandlerMap;

    class OutputState
    {
    public:
        OutputState(const char* state_name, DEVS::OutputMessage* message) : state_name_(state_name), message_(message)
        {}

        const std::string& state_name() const { return state_name_; }
        DEVS::OutputMessage* message() const { return message_; } 
    private:
        std::string state_name_;
        DEVS::OutputMessage* message_;
    };
    std::list<OutputState> outputStates_;

private:
    unsigned long mote_id_;
    RunTaskFunctionHandle runTaskFunction_;
    ExternalMensageHandlerMap externalMessageHandlers_ ;

    bool started_;

};

#endif
